// Generated by CoffeeScript 1.12.1
(function() {
  var Client, ClientSocket, DEFAULT_QUEUE_SIZE, DEFAULT_RECONNECT_TIME_IN_MS, EventEmitter, MIN_TIME_BETWEEN_DROPPED_EVENTS_IN_MS, assert,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  assert = require('assert');

  EventEmitter = require('events').EventEmitter;

  ClientSocket = require('./ClientSocket');

  DEFAULT_QUEUE_SIZE = 500;

  DEFAULT_RECONNECT_TIME_IN_MS = 3000;

  MIN_TIME_BETWEEN_DROPPED_EVENTS_IN_MS = 1000;

  Client = (function(superClass) {
    extend(Client, superClass);

    function Client(tlsConnectOptions, options) {
      var ref, ref1, ref2;
      this.tlsConnectOptions = tlsConnectOptions;
      this.options = options != null ? options : {};
      this._disconnect = bind(this._disconnect, this);
      this.connected = false;
      this._closed = false;
      this._hostname = require('os').hostname();
      this._queue = [];
      this._maxQueueSize = (ref = this.options.maxQueueSize) != null ? ref : DEFAULT_QUEUE_SIZE;
      this._reconnectTime = (ref1 = this.options.reconnect) != null ? ref1 : DEFAULT_RECONNECT_TIME_IN_MS;
      this._minTimeBetweenDropEvents = (ref2 = this.options.minTimeBetweenDropEvents) != null ? ref2 : MIN_TIME_BETWEEN_DROPPED_EVENTS_IN_MS;
      this._connect();
      this._lastDropEventTime = null;
      this._dropTimer = null;
      this._dropCount = 0;
      this.queueHighWatermark = 0;
    }

    Client.prototype.writeDataFrame = function(data) {
      var key, record, value;
      if (this._closed) {
        throw new Error("Client is closed");
      }
      if (!this.connected || !this._socket) {
        return this._queueMessage(data);
      } else {
        if (data.host == null) {
          record = {};
          for (key in data) {
            value = data[key];
            record[key] = value;
          }
          record.host = this._hostname;
          data = record;
        }
        return this._socket.writeDataFrame(data, (function(_this) {
          return function(err) {
            if ((err != null) && !(err instanceof ClientSocket.DroppedError)) {
              return _this._queueMessage(data);
            }
          };
        })(this));
      }
    };

    Client.prototype.close = function() {
      this._closed = true;
      return this._disconnect();
    };

    Client.prototype._connect = function() {
      if (this._closed) {
        return;
      }
      if (this.options._connect != null) {
        this._socket = this.options._connect(this, this.tlsConnectOptions);
      } else {
        this._socket = new ClientSocket(this.options);
        this._socket.connect(this.tlsConnectOptions);
      }
      this._socket.on('connect', (function(_this) {
        return function() {
          _this.connected = true;
          _this.emit('connect');
          _this._sendQueuedMessages();
          if (_this.options.unref) {
            return _this._socket.unref();
          }
        };
      })(this));
      this._socket.on('end', this._disconnect);
      this._socket.on('error', this._disconnect);
      return this._socket.on('dropped', (function(_this) {
        return function(count) {
          return _this._dropped(count);
        };
      })(this));
    };

    Client.prototype._disconnect = function(err) {
      var ref;
      this.connected = false;
      if (this._socket != null) {
        this._socket.close();
        if ((ref = this._socket) != null) {
          ref.removeAllListeners();
        }
        this._socket = null;
      }
      this.emit('disconnect', err);
      if (!this._closed && (this._connectTimer == null)) {
        return this._connectTimer = setTimeout(((function(_this) {
          return function() {
            _this._connectTimer = null;
            return _this._connect();
          };
        })(this)), this._reconnectTime);
      }
    };

    Client.prototype._queueMessage = function(data) {
      var originalQueueSize;
      this._queue.push(data);
      this.queueHighWatermark = Math.max(this._queue.length, this.queueHighWatermark);
      if (this._queue.length >= this._maxQueueSize) {
        originalQueueSize = this._queue.length;
        if (this.options.allowDrop != null) {
          this._queue = this._queue.filter(this.options.allowDrop);
        }
        while (this._queue.length >= this._maxQueueSize) {
          this._queue.shift();
        }
        return this._dropped(originalQueueSize - this._queue.length);
      }
    };

    Client.prototype._sendQueuedMessages = function() {
      var message;
      if (this._queue.length === 0 || (this._socket == null)) {
        return;
      }
      message = this._queue.shift();
      return this._socket.writeDataFrame(message, (function(_this) {
        return function(err) {
          if ((err != null) && !(err instanceof ClientSocket.DroppedError)) {
            return _this._queue.unshift(message);
          } else {
            return setImmediate(function() {
              return _this._sendQueuedMessages();
            });
          }
        };
      })(this));
    };

    Client.prototype._dropped = function(count) {
      var sendDropEvent;
      this._dropCount += count;
      if (this._dropTimer != null) {
        return;
      }
      sendDropEvent = (function(_this) {
        return function() {
          _this.emit('dropped', _this._dropCount);
          _this._dropCount = 0;
          _this._dropTimer = null;
          return _this._lastDropEventTime = Date.now();
        };
      })(this);
      if ((this._lastDropEventTime == null) || this._lastDropEventTime + this._minTimeBetweenDropEvents < Date.now()) {
        return sendDropEvent();
      } else {
        return this._dropTimer = setTimeout(sendDropEvent, this._minTimeBetweenDropEvents);
      }
    };

    return Client;

  })(EventEmitter);

  module.exports = Client;

}).call(this);
